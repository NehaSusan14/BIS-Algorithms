import numpy as np
import random
import matplotlib.pyplot as plt

# Step 1: Generate some sample data (y = ax^2 + bx + c with noise)
np.random.seed(42)
x_data = np.linspace(-10, 10, 100)  # 100 data points
y_data = 2 * x_data**2 + 3 * x_data + 5 + np.random.normal(0, 5, size=x_data.shape)

# Step 2: Define the fitness function
def fitness_function(coefficients):
    a, b, c = coefficients  # Coefficients for the polynomial: y = ax^2 + bx + c
    y_pred = a * x_data**2 + b * x_data + c  # Predicted y values using the polynomial
    mse = np.mean((y_pred - y_data)**2)  # Mean Squared Error
    return mse  # The goal is to minimize MSE

# Step 3: Particle Swarm Optimization (PSO)
class PSO:
    def __init__(self, num_particles, dimensions, bounds, max_iter):
        self.num_particles = num_particles
        self.dimensions = dimensions
        self.bounds = bounds
        self.max_iter = max_iter
        
        # Initialize particles and their velocities
        self.positions = np.random.uniform(bounds[0], bounds[1], (num_particles, dimensions))
        self.velocities = np.random.uniform(-1, 1, (num_particles, dimensions))
        
        # Best positions and fitness
        self.best_positions = np.copy(self.positions)
        self.best_fitness = np.array([fitness_function(p) for p in self.best_positions])
        
        # Global best position
        self.global_best_position = self.best_positions[np.argmin(self.best_fitness)]
        self.global_best_fitness = np.min(self.best_fitness)
    
    def update_particles(self, w=0.5, c1=1.5, c2=1.5):
        for i in range(self.num_particles):
            # Update velocity
            r1 = np.random.random(self.dimensions)
            r2 = np.random.random(self.dimensions)
            
            self.velocities[i] = (w * self.velocities[i] +
                                  c1 * r1 * (self.best_positions[i] - self.positions[i]) +
                                  c2 * r2 * (self.global_best_position - self.positions[i]))
            
            # Update position
            self.positions[i] += self.velocities[i]
            
            # Ensure the particle stays within bounds
            self.positions[i] = np.clip(self.positions[i], self.bounds[0], self.bounds[1])
            
            # Evaluate fitness
            fitness = fitness_function(self.positions[i])
            
            # Update personal best
            if fitness < self.best_fitness[i]:
                self.best_fitness[i] = fitness
                self.best_positions[i] = self.positions[i]
                
            # Update global best
            if fitness < self.global_best_fitness:
                self.global_best_fitness = fitness
                self.global_best_position = self.positions[i]
    
    def optimize(self):
        for iteration in range(self.max_iter):
            self.update_particles()
            if iteration % 10 == 0:
                print(f"Iteration {iteration}: Best Fitness = {self.global_best_fitness}")

# Step 4: Run the PSO algorithm
pso = PSO(num_particles=30, dimensions=3, bounds=(-10, 10), max_iter=100)
pso.optimize()

# Step 5: Extract the best coefficients from the global best position
best_a, best_b, best_c = pso.global_best_position
print(f"Best coefficients found: a = {best_a:.4f}, b = {best_b:.4f}, c = {best_c:.4f}")

# Step 6: Plot the results
y_fit = best_a * x_data**2 + best_b * x_data + best_c

plt.scatter(x_data, y_data, label='Data', color='blue')
plt.plot(x_data, y_fit, label='Fitted Curve', color='red', linewidth=2)
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.title('Curve Fitting using Particle Swarm Optimization (PSO)')
plt.show()
