import numpy as np
import matplotlib.pyplot as plt

def fitness(pixel_val, neighbors):
    """
    Fitness function: measures smoothness of a pixel relative to neighbors.
    Higher fitness when pixel value is closer to neighbors.
    
    Args:
      pixel_val (float): value of the current pixel.
      neighbors (np.array): array of neighbor pixel values.
      
    Returns:
      float: fitness score (higher is better).
    """
    return -np.sum((neighbors - pixel_val) ** 2)


def update_rule(current_val, neighbors):
    """
    Update rule for pixel value based on neighbors.
    Proposes a candidate pixel value as the average of current and neighbors.
    
    Args:
      current_val (float): current pixel value.
      neighbors (np.array): array of neighbor pixel values.
    
    Returns:
      float: new pixel value candidate.
    """
    return (current_val + neighbors.sum()) / (len(neighbors) + 1)


def get_neighbors(image, x, y):
    """
    Get neighbors of pixel (x, y) using Moore neighborhood.
    
    Args:
      image (2D np.array): grayscale image.
      x, y (int): pixel coordinates.
    
    Returns:
      np.array: neighbor pixel values.
    """
    neighbors = []
    rows, cols = image.shape
    for i in range(max(0, x - 1), min(rows, x + 2)):
        for j in range(max(0, y - 1), min(cols, y + 2)):
            if i == x and j == y:
                continue
            neighbors.append(image[i, j])
    return np.array(neighbors)


def pca_image_denoise(noisy_image, iterations=10):
    """
    Perform PCA-based image denoising.
    
    Args:
      noisy_image (2D np.array): noisy input image.
      iterations (int): number of PCA iterations.
    
    Returns:
      2D np.array: denoised image.
    """
    image = noisy_image.copy()
    rows, cols = image.shape
    
    for it in range(iterations):
        new_image = image.copy()
        
        for x in range(rows):
            for y in range(cols):
                neighbors = get_neighbors(image, x, y)
                current_val = image[x, y]
                candidate_val = update_rule(current_val, neighbors)
                
                # Compute fitness of current and candidate pixel
                fitness_current = fitness(current_val, neighbors)
                fitness_candidate = fitness(candidate_val, neighbors)
                
                # Update if candidate fitness is better
                if fitness_candidate > fitness_current:
                    new_image[x, y] = candidate_val
        
        image = new_image
    
    return image


# --- Example usage ---

# Create synthetic image with noise
original = np.zeros((50, 50))
original[15:35, 15:35] = 1.0  # white square

np.random.seed(42)
noisy = original + 0.4 * np.random.randn(*original.shape)
noisy = np.clip(noisy, 0, 1)

denoised = pca_image_denoise(noisy, iterations=15)

# Plot results
plt.figure(figsize=(12,4))
plt.subplot(1,3,1)
plt.title("Original Image")
plt.imshow(original, cmap='gray')
plt.axis('off')

plt.subplot(1,3,2)
plt.title("Noisy Image")
plt.imshow(noisy, cmap='gray')
plt.axis('off')

plt.subplot(1,3,3)
plt.title("Denoised Image")
plt.imshow(denoised, cmap='gray')
plt.axis('off')

plt.show()
